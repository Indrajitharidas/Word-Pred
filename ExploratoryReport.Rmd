#Exploration of Text Prediction Data
##Eric Koziol

```{r, cache=TRUE, warning = FALSE, message=FALSE, echo=FALSE}
require(tm)
require(openNLP)
require(RWeka)

data_blogs = readLines("Raw_Data/en_US/en_US.blogs.txt")
data_twitter=readLines("Raw_Data/en_US/en_US.twitter.txt")
data_news=readLines("Raw_Data/en_US/en_US.news.txt")
#load(eCorp.RData)
profanity <- read.csv("ProfanityWords.csv", header=FALSE)
profanity <- profanity$V1

scrubData <- function(x){
  x <- gsub("[^a-zA-Z ]", "", x)
  x <- gsub(paste(profanity, collapse='|'), " ", x)
  x <- strsplit(x," ")
  
  
  return(x)
}

#s_news <- scrubData(data_news)
#s_news <- unlist(s_news)
#s_news_freq <- sort(table(paste(s_news, s_news)), decreasing = T)
#s_news_freq_num <- c()
#s_news_freq <- as.integer(s_news_freq)
#for(b in names(s_news_freq)){s_news_freq_num <- c(s_news_freq_num, s_news_freq[b])}
#quantile(s_news_freq, c(0.1, 0.25, 0.5, 0.75, 0.9))
#qplot(log(s_news_freq)) + geom_vline(xintercept = log(quantile(s_news_freq, c(0.1, 0.25, 0.5, 0.75, 0.9))[3]), color = "blue",linetype = "longdash") + geom_vline(xintercept = log(quantile(s_news_freq, c(0.1, 0.25, 0.5, 0.75, 0.9))[1]), color = "red", linetype = "longdash") + annotate("text",  x= log(3), y = sum(s_news_freq > 2), label = "50% threshold")
```

##Summary
This document explores the available data to us in our quest to create a predictive text app.  We have over **`r length(data_twitter) + length(data_blogs) + length(data_blogs)`** different text documents at our disposal.

##Initial Data
The data received is in the form of three English text corpora.  The first corpus contains data from twitter, the second data from various blogs and the third from various news sources.  The number of entries within each corpus can be viewed in the table below:

Corpus  | Number of Entries
--------|------------------
Twitter | `r length(data_twitter)`
Blogs   | `r length(data_blogs)`
News    | `r length(data_blogs)`


###Twitter


###Blogs

###News

##Future Steps
Based on this data the following will be performed in order to create a text prediction software:
1.  Convert rare words to <UNK> tag.  This will be used to interpret words that have not been seen before.
2.  Convert the data to n-grams for further processing.
3.  Create probabilty tables for the n-grams.
4.  Build prediction algorithms based on Markov Chaining of conditional probabilities of sentences.  Use perplexity to measure the effects of different smoothing.
5.  After an algorithm has been successfully accepted, an application for users to enter data and use predictions will be created.